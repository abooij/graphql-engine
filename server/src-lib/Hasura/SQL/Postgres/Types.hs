module Hasura.SQL.Postgres.Types
  ( PGScalarType(..)
  , textToPGScalarType
  , pgTypeOid
  , isIntegerType
  , isNumType
  , stringTypes
  , isStringType
  , isJSONType
  , isComparableType
  , isBigNum
  , geoTypes
  , isGeoType

  , WithScalarType(..)
  , PGType(..)
  , PGTypeKind(..)
  , QualifiedPGType(..)
  , isBaseType
  , typeToTable
  ) where

import           Hasura.Prelude

import qualified Data.Text.Extended         as T
import qualified Database.PG.Query.PTI      as PTI
import qualified Database.PostgreSQL.LibPQ  as PQ
import qualified Text.Builder               as TB

import           Data.Aeson
import           Data.Aeson.Casing
import           Data.Aeson.TH
import           Data.Aeson.Types           (toJSONKeyText)
import           Instances.TH.Lift          ()
import           Language.Haskell.TH.Syntax (Lift)

import           Hasura.Incremental         (Cacheable)
import           Hasura.SQL.Types

data PGScalarType
  = PGSmallInt
  | PGInteger
  | PGBigInt
  | PGSerial
  | PGBigSerial
  | PGFloat
  | PGDouble
  | PGNumeric
  | PGMoney
  | PGBoolean
  | PGChar
  | PGVarchar
  | PGText
  | PGCitext
  | PGDate
  | PGTimeStamp
  | PGTimeStampTZ
  | PGTimeTZ
  | PGJSON
  | PGJSONB
  | PGGeometry
  | PGGeography
  | PGRaster
  | PGUUID
  | PGUnknown !T.Text
  deriving (Show, Eq, Ord, Lift, Generic, Data)
instance NFData PGScalarType
instance Hashable PGScalarType
instance Cacheable PGScalarType

instance ToSQL PGScalarType where
  toSQL = \case
    PGSmallInt    -> "smallint"
    PGInteger     -> "integer"
    PGBigInt      -> "bigint"
    PGSerial      -> "serial"
    PGBigSerial   -> "bigserial"
    PGFloat       -> "real"
    PGDouble      -> "float8"
    PGNumeric     -> "numeric"
    PGMoney       -> "money"
    PGBoolean     -> "boolean"
    PGChar        -> "character"
    PGVarchar     -> "varchar"
    PGText        -> "text"
    PGCitext      -> "citext"
    PGDate        -> "date"
    PGTimeStamp   -> "timestamp"
    PGTimeStampTZ -> "timestamptz"
    PGTimeTZ      -> "timetz"
    PGJSON        -> "json"
    PGJSONB       -> "jsonb"
    PGGeometry    -> "geometry"
    PGGeography   -> "geography"
    PGRaster      -> "raster"
    PGUUID        -> "uuid"
    PGUnknown t   -> TB.text t

instance ToJSON PGScalarType where
  toJSON = String . toSQLTxt

instance ToJSONKey PGScalarType where
  toJSONKey = toJSONKeyText toSQLTxt

instance DQuote PGScalarType where
  dquoteTxt = toSQLTxt

textToPGScalarType :: Text -> PGScalarType
textToPGScalarType t = fromMaybe (PGUnknown t) (lookup t pgScalarTranslations)

-- Inlining this results in pretty terrible Core being generated by GHC.

{-# NOINLINE pgScalarTranslations #-}
pgScalarTranslations :: [(Text, PGScalarType)]
pgScalarTranslations =
  [ ("serial"                      , PGSerial)
  , ("bigserial"                   , PGBigSerial)

  , ("smallint"                    , PGSmallInt)
  , ("int2"                        , PGSmallInt)

  , ("integer"                     , PGInteger)
  , ("int4"                        , PGInteger)

  , ("bigint"                      , PGBigInt)
  , ("int8"                        , PGBigInt)

  , ("real"                        , PGFloat)
  , ("float4"                      , PGFloat)

  , ("double precision"            , PGDouble)
  , ("float8"                      , PGDouble)

  , ("numeric"                     , PGNumeric)
  , ("decimal"                     , PGNumeric)

  , ("money"                       , PGMoney)

  , ("boolean"                     , PGBoolean)
  , ("bool"                        , PGBoolean)

  , ("character"                   , PGChar)

  , ("varchar"                     , PGVarchar)
  , ("character varying"           , PGVarchar)

  , ("text"                        , PGText)
  , ("citext"                      , PGCitext)

  , ("date"                        , PGDate)

  , ("timestamp"                   , PGTimeStamp)
  , ("timestamp without time zone" , PGTimeStamp)

  , ("timestamptz"                 , PGTimeStampTZ)
  , ("timestamp with time zone"    , PGTimeStampTZ)

  , ("timetz"                      , PGTimeTZ)
  , ("time with time zone"         , PGTimeTZ)

  , ("json"                        , PGJSON)
  , ("jsonb"                       , PGJSONB)

  , ("geometry"                    , PGGeometry)
  , ("geography"                   , PGGeography)

  , ("raster"                      , PGRaster)
  , ("uuid"                        , PGUUID)
  ]

instance FromJSON PGScalarType where
  parseJSON (String t) = return $ textToPGScalarType t
  parseJSON _          = fail "Expecting a string for PGScalarType"

pgTypeOid :: PGScalarType -> PQ.Oid
pgTypeOid PGSmallInt    = PTI.int2
pgTypeOid PGInteger     = PTI.int4
pgTypeOid PGBigInt      = PTI.int8
pgTypeOid PGSerial      = PTI.int4
pgTypeOid PGBigSerial   = PTI.int8
pgTypeOid PGFloat       = PTI.float4
pgTypeOid PGDouble      = PTI.float8
pgTypeOid PGNumeric     = PTI.numeric
pgTypeOid PGMoney       = PTI.numeric
pgTypeOid PGBoolean     = PTI.bool
pgTypeOid PGChar        = PTI.char
pgTypeOid PGVarchar     = PTI.varchar
pgTypeOid PGText        = PTI.text
pgTypeOid PGCitext      = PTI.text -- Explict type cast to citext needed, See also Note [Type casting prepared params]
pgTypeOid PGDate        = PTI.date
pgTypeOid PGTimeStamp   = PTI.timestamp
pgTypeOid PGTimeStampTZ = PTI.timestamptz
pgTypeOid PGTimeTZ      = PTI.timetz
pgTypeOid PGJSON        = PTI.json
pgTypeOid PGJSONB       = PTI.jsonb
pgTypeOid PGGeometry    = PTI.text -- we are using the ST_GeomFromGeoJSON($i) instead of $i
pgTypeOid PGGeography   = PTI.text
pgTypeOid PGRaster      = PTI.text -- we are using the ST_RastFromHexWKB($i) instead of $i
pgTypeOid PGUUID        = PTI.uuid
pgTypeOid (PGUnknown _) = PTI.auto

isIntegerType :: PGScalarType -> Bool
isIntegerType PGInteger  = True
isIntegerType PGSmallInt = True
isIntegerType PGBigInt   = True
isIntegerType _          = False

isNumType :: PGScalarType -> Bool
isNumType PGFloat   = True
isNumType PGDouble  = True
isNumType PGNumeric = True
isNumType PGMoney   = True
isNumType ty        = isIntegerType ty

stringTypes :: [PGScalarType]
stringTypes = [PGVarchar, PGText, PGCitext]

isStringType :: PGScalarType -> Bool
isStringType = (`elem` stringTypes)

jsonTypes :: [PGScalarType]
jsonTypes = [PGJSON, PGJSONB]

isJSONType :: PGScalarType -> Bool
isJSONType = (`elem` jsonTypes)

isComparableType :: PGScalarType -> Bool
isComparableType PGJSON        = False
isComparableType PGJSONB       = False
isComparableType PGGeometry    = False
isComparableType PGGeography   = False
isComparableType PGBoolean     = False
isComparableType (PGUnknown _) = False
isComparableType _             = True

isBigNum :: PGScalarType -> Bool
isBigNum = \case
  PGBigInt    -> True
  PGBigSerial -> True
  PGNumeric   -> True
  PGDouble    -> True
  PGMoney     -> True
  _           -> False

geoTypes :: [PGScalarType]
geoTypes = [PGGeometry, PGGeography]

isGeoType :: PGScalarType -> Bool
isGeoType = (`elem` geoTypes)

data WithScalarType a
  = WithScalarType
  { pstType  :: !PGScalarType
  , pstValue :: !a
  } deriving (Show, Eq, Functor, Foldable, Traversable)

-- | The type of all Postgres types (i.e. scalars and arrays). This type is parameterized so that
-- we can have both @'PGType' 'PGScalarType'@ and @'PGType' 'Hasura.RQL.Types.PGColumnType'@, for
-- when we care about the distinction made by 'Hasura.RQL.Types.PGColumnType'. If we ever change
-- 'Hasura.RQL.Types.PGColumnType' to handle arrays, not just scalars, then the parameterization can
-- go away.
--
-- TODO (from master): This is incorrect modeling, as 'PGScalarType' will capture anything (under 'PGUnknown').
-- This should be fixed when support for all types is merged.
data PGType a
  = PGTypeScalar !a
  | PGTypeArray !a
  deriving (Show, Eq, Generic, Data, Functor)
instance (NFData a) => NFData (PGType a)
instance (Cacheable a) => Cacheable (PGType a)
$(deriveJSON defaultOptions{constructorTagModifier = drop 6} ''PGType)

instance (ToSQL a) => ToSQL (PGType a) where
  toSQL = \case
    PGTypeScalar ty -> toSQL ty
    -- typename array is an sql standard way of declaring types
    PGTypeArray ty -> toSQL ty <> " array"

data PGTypeKind
  = PGKindBase
  | PGKindComposite
  | PGKindDomain
  | PGKindEnum
  | PGKindRange
  | PGKindPseudo
  | PGKindUnknown !T.Text
  deriving (Show, Eq, Generic)
instance NFData PGTypeKind
instance Cacheable PGTypeKind

instance FromJSON PGTypeKind where
  parseJSON = withText "postgresTypeKind" $
    \t -> pure $ case t of
      "b" -> PGKindBase
      "c" -> PGKindComposite
      "d" -> PGKindDomain
      "e" -> PGKindEnum
      "r" -> PGKindRange
      "p" -> PGKindPseudo
      _   -> PGKindUnknown t

instance ToJSON PGTypeKind where
  toJSON = \case
    PGKindBase      -> "b"
    PGKindComposite -> "c"
    PGKindDomain    -> "d"
    PGKindEnum      -> "e"
    PGKindRange     -> "r"
    PGKindPseudo    -> "p"
    PGKindUnknown t -> String t

data QualifiedPGType
  = QualifiedPGType
  { _qptSchema :: !SchemaName
  , _qptName   :: !PGScalarType
  , _qptType   :: !PGTypeKind
  } deriving (Show, Eq, Generic)
instance NFData QualifiedPGType
instance Cacheable QualifiedPGType
$(deriveJSON (aesonDrop 4 snakeCase) ''QualifiedPGType)

isBaseType :: QualifiedPGType -> Bool
isBaseType (QualifiedPGType _ n ty) =
  notUnknown && (ty == PGKindBase)
  where
    notUnknown = case n of
      PGUnknown _ -> False
      _           -> True

typeToTable :: QualifiedPGType -> QualifiedTable
typeToTable (QualifiedPGType sch n _) =
  QualifiedObject sch $ TableName $ toSQLTxt n
